// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.0;

import "./Setup.sol";

uint256 constant p = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

contract Exploit {
    Challenge private chal;

    constructor(Setup setup) {
        chal = setup.challenge();
        solve1();
        solve2();
        solve3();
        chal.declareSolved();
    }

    function solve1() private {
        uint256[] memory f = new uint256[](1);
        uint256[] memory t = new uint256[](2);
        uint256[] memory s1 = new uint256[](2);
        uint256[] memory s2 = new uint256[](2);
        f[0] = 1;
        t[0] = 2;
        t[1] = 2;
        s1[0] = 1;
        s1[1] = 1;
        s2[0] = 2;
        s2[1] = 2;
        chal.challenge1(1, f, t, s1, s2);
        require(chal.solved1());
    }

    function solve2() private {
        uint256 beta = 16368728672139209675189426146787579641292211471271302196885660986090374075426;
        uint256 gamma = 18571253505803504063423604873714424735789713317667450421033088549733644694631;

        uint dummy_count = 10;
        bytes memory callData = abi.encodePacked(
            bytes4(keccak256(bytes("challenge2(uint256,uint256[],uint256[],uint256[],uint256[])"))),
            uint256(1), // N
            uint256((5 + dummy_count) * 32), // Offset f
            uint256((7 + dummy_count) * 32), // Offset t
            uint256((10 + dummy_count) * 32), // Offset s1
            uint256((13 + dummy_count) * 32) // Offset s2
        );
        for (uint i = 0; i < dummy_count; i++) {
            callData = abi.encodePacked(callData, uint256(0));
        }
        callData = abi.encodePacked(callData,
            uint256(1), // f.length
            uint256(2) // f[0]
        );
        callData = abi.encodePacked(callData,
            uint256(2), // t.length
            uint256(1), // t[0]
            uint256(1) // t[1]
        );
        callData = abi.encodePacked(callData,
            uint256(2), // s1.length
            uint256((beta + 2) % p), // s1[0]
            uint256(1) // s1[1]
        );
        callData = abi.encodePacked(callData,
            uint256(2), // s1.length
            uint256(1), // s2[0]
            uint256(1) // s2[1]
        );
        (bool success, bytes memory returnData) = address(chal).call(callData);
        require(chal.solved2());
    }

    function solve3() private {
        uint256[] memory f = new uint256[](1);
        uint256[] memory t = new uint256[](2);
        uint256[] memory s1 = new uint256[](2);
        uint256[] memory s2 = new uint256[](2);
        f[0] = 1;
        t[0] = 9;
        t[1] = 5;
        s1[0] = 3;
        s1[1] = 3;
        s2[0] = 3;
        s2[1] = 3;
        chal.challenge3(1, f, t, s1, s2);
        require(chal.solved3());
    }
}
